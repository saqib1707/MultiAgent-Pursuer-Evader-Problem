# -*- coding: utf-8 -*-
"""tf_api_rnn_learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U5HENKs9UCCZCLvjhOk1zxTZtvAzGYB3
"""

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt

# hyperparameters
window_size = 5
batch_size = 200
num_classes = 2
learning_rate = 0.1
state_size = 4
num_samples = 10000
num_training_epochs = 10

def generate_data():
  X = np.random.choice(a=[0,1], size=(num_samples))
  Y = []
  for index in range(num_samples):
    thresh = 0.5
    if X[index-3] == 1:
      thresh += 0.5
    if X[index-8] == 1:
      thresh -= 0.25
    if np.random.rand() > thresh:
      Y.append(0)
    else:
      Y.append(1)
  return X, np.array(Y)

def get_next_batch(epoch_size, index):
  return data_x[:,index*window_size:(index+1)*window_size], data_y[:,index*window_size:(index+1)*window_size]

raw_x, raw_y = generate_data()

batch_partition_length = num_samples//batch_size
data_x = np.zeros([batch_size, batch_partition_length], dtype=np.int32)
data_y = np.zeros([batch_size, batch_partition_length], dtype=np.int32)

for i in range(batch_size):
  data_x[i] = raw_x[batch_partition_length*i:batch_partition_length*(i+1)]
  data_y[i] = raw_y[batch_partition_length*i:batch_partition_length*(i+1)]

x = tf.placeholder(dtype=tf.int32, shape=[batch_size, window_size], name='input_placeholder')
y = tf.placeholder(dtype=tf.int32, shape=[batch_size, window_size], name='label_placeholder')
init_state = tf.zeros(shape=[batch_size, state_size], dtype=tf.float32)

rnn_inputs = tf.one_hot(x, num_classes)     # [batch_size, window_size, features]

cell = tf.contrib.rnn.BasicRNNCell(state_size)
rnn_outputs, final_state = tf.nn.dynamic_rnn(cell, rnn_inputs, initial_state=init_state)   # output[:,-1,:] = final_state[:,:], rnn_outputs.shape = [batch_size,window_size,state_size]

# sess = tf.Session()
# sess.run(tf.global_variables_initializer())
# temp_x = np.random.randint(0,2,[batch_size,window_size])
# temp_y = np.random.randint(0,2,[batch_size,window_size])
# output, fs = sess.run([rnn_outputs,final_state], feed_dict={x:temp_x, y:temp_y})
# print(output.shape, fs.shape)
# print(output[:,3,:] - fs)

def class_scores():
	with tf.variable_scope('softmax_predictions',reuse=tf.AUTO_REUSE):
	  weight = tf.get_variable(name='w', shape=[state_size,num_classes])
	  bias = tf.get_variable(name='b', shape=[num_classes], initializer=tf.constant_initializer(0.0))
	logits = tf.reshape(tf.add(tf.matmul(tf.reshape(rnn_outputs,[-1,state_size]),weight),bias),[batch_size,window_size,num_classes])
	return logits

logits = class_scores()
output_predictions = tf.nn.softmax(logits)

losses = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=y)
total_loss = tf.reduce_mean(losses)
train_step = tf.train.AdamOptimizer(learning_rate).minimize(total_loss)

def train_network(num_epochs):
  with tf.Session() as sess:
    sess.run(tf.global_variables_initializer())
    training_loss = []

    epoch_size = batch_partition_length//window_size
    
    for epoch in range(num_epochs):
      for index in range(epoch_size):
        [batch_x, batch_y] = get_next_batch(epoch_size, index)
        _, loss_val = sess.run([train_step, total_loss], feed_dict={x:batch_x, y:batch_y})
        training_loss.append(loss_val)
        print("Epoch :", epoch, "iteration :", index, "Loss Value :", loss_val)
  return training_loss

training_losses = train_network(num_epochs=num_training_epochs)
plt.plot(training_losses)
plt.show()